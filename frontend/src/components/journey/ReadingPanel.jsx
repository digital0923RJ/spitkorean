import React, { useState, useEffect, useRef, useCallback } from 'react';
// Redux Ïï°ÏÖò importuseDispatch, useSelector } from 'react-redux';
import toast from 'react-hot-toast';
import { 
  Play, 
  Pause, 
  Square, 
  SkipForward, 
  SkipBack,
  RotateCcw,
  BookOpen,
  Eye,
  EyeOff,
  Lightbulb,
  Volume2,
  VolumeX,
  ArrowLeft,
  ArrowRight,
  ChevronUp,
  ChevronDown
} from 'lucide-react';
import Button from '../common/Button';
import LoadingSpinner from '../common/LoadingSpinner';
import SpeedControl from './SpeedControl';
import HangulDisplay from './HangulDisplay';
import PronunciationFeedback from './PronunciationFeedback';

// ÏùΩÍ∏∞ Ìå®ÎÑê Ï†ÑÏö© Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
const readingPanelUtils = {
  // Îã§Ïùå ÎÇ† ÏûêÏ†ïÍπåÏßÄÏùò ÏãúÍ∞Ñ Í≥ÑÏÇ∞
  getNextMidnight: () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    return tomorrow.toISOString();
  },

  // ÌòÑÏû¨ ÏãúÍ∞ÑÏùÑ ISO Î¨∏ÏûêÏó¥Î°ú Î∞òÌôò
  getCurrentISO: () => {
    return new Date().toISOString();
  },

  // Îëê ÎÇ†Ïßú Í∞ÑÏùò ÏãúÍ∞Ñ Ï∞®Ïù¥ Í≥ÑÏÇ∞ (Î∞ÄÎ¶¨Ï¥à)
  getTimeDifference: (startTime) => {
    return Date.now() - startTime;
  }
};

// Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
const dateUtils = {
  // Îã§Ïùå ÎÇ† ÏûêÏ†ïÍπåÏßÄÏùò ÏãúÍ∞Ñ Í≥ÑÏÇ∞
  getNextMidnight: () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    return tomorrow.toISOString();
  },

  // ÌòÑÏû¨ ÏãúÍ∞ÑÏùÑ ISO Î¨∏ÏûêÏó¥Î°ú Î∞òÌôò
  getCurrentISO: () => {
    return new Date().toISOString();
  },

  // Îëê ÎÇ†Ïßú Í∞ÑÏùò ÏãúÍ∞Ñ Ï∞®Ïù¥ Í≥ÑÏÇ∞ (Î∞ÄÎ¶¨Ï¥à)
  getTimeDifference: (startTime) => {
    return Date.now() - startTime;
  }
};

// ÌõÖ import
import useVoice from '../../hooks/useVoice';
import { 
  fetchJourneyContent,
  submitReading,
  startSession,
  endSession,
  setCurrentSentence,
  goToNextSentence,
  goToPreviousSentence,
  markSentenceCompleted,
  setPlaybackState,
  setPlaybackSpeed,
  setVolume,
  toggleMute,
  startRecording,
  stopRecording,
  setPronunciationScore,
  toggleGuide,
  toggleTranslation,
  selectCurrentContent,
  selectSession,
  selectPlayback,
  selectRecording,
  selectPronunciation,
  selectUI,
  selectLoading,
  selectCurrentSentence,
  selectCanGoNext,
  selectCanGoPrevious
} from '../../store/slices/journeySlice';

const ReadingPanel = ({ 
  content = null,
  level = 'level1',
  onComplete = null,
  onProgress = null,
  className = '' 
}) => {
  // Redux ÏÉÅÌÉú Î∞è ÎîîÏä§Ìå®Ïπò
  const dispatch = useDispatch();
  const currentContent = useSelector(selectCurrentContent);
  const session = useSelector(selectSession);
  const playback = useSelector(selectPlayback);
  const recording = useSelector(selectRecording);
  const pronunciation = useSelector(selectPronunciation);
  const ui = useSelector(selectUI);
  const loading = useSelector(selectLoading);
  const currentSentence = useSelector(selectCurrentSentence);
  const canGoNext = useSelector(selectCanGoNext);
  const canGoPrevious = useSelector(selectCanGoPrevious);

  // useVoice ÌõÖ ÏÇ¨Ïö©
  const {
    isRecording,
    isProcessing,
    isPlayingTTS,
    audioLevel,
    recordingDuration,
    startRecording: startVoiceRecording,
    stopRecording: stopVoiceRecording,
    playTTS,
    analyzePronunciationAudio,
    voiceSettings,
    updateVoiceSettings
  } = useVoice();

  // Î°úÏª¨ ÏÉÅÌÉú (ReduxÏôÄ Ïó∞Îèô)
  const [startTime, setStartTime] = useState(null);
  
  // Î†àÌçºÎü∞Ïä§
  const textRef = useRef(null);

  // Î†àÎ≤®Î≥Ñ ÏÑ§Ï†ï
  const levelConfigs = {
    level1: {
      name: 'ÌïúÍ∏Ä ÎßàÏä§ÌÑ∞',
      defaultSpeed: 0.5,
      showHangulBreakdown: true,
      autoAdvance: true,
      features: ['hangul_guide', 'basic_pronunciation']
    },
    level2: {
      name: 'Í∏∞Ï¥à Î¶¨Îçî',
      defaultSpeed: 0.8,
      showHangulBreakdown: false,
      autoAdvance: true,
      features: ['pronunciation_rules', 'basic_vocabulary']
    },
    level3: {
      name: 'Ï§ëÍ∏â Î¶¨Îçî',
      defaultSpeed: 1.0,
      showHangulBreakdown: false,
      autoAdvance: false,
      features: ['intonation', 'connected_speech']
    },
    level4: {
      name: 'Í≥†Í∏â Î¶¨Îçî',
      defaultSpeed: 1.2,
      showHangulBreakdown: false,
      autoAdvance: false,
      features: ['natural_rhythm', 'advanced_expressions']
    }
  };

  const config = levelConfigs[level] || levelConfigs.level1;

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    if (!currentContent && !loading.content) {
      // ÏΩòÌÖêÏ∏†Í∞Ä ÏóÜÏúºÎ©¥ Î°úÎìú
      dispatch(fetchJourneyContent({ level, type: 'reading' }));
    }
  }, [dispatch, currentContent, loading.content, level]);

  // ÏΩòÌÖêÏ∏† Î≥ÄÍ≤Ω Ïãú ÏÑ∏ÏÖò ÏãúÏûë
  useEffect(() => {
    if (currentContent && !session.isActive) {
      dispatch(startSession({ content: currentContent }));
      dispatch(setPlaybackSpeed(config.defaultSpeed));
      setStartTime(Date.now());
    }
  }, [dispatch, currentContent, session.isActive, config.defaultSpeed]);

  // ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§
  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      switch (e.key) {
        case ' ':
          e.preventDefault();
          togglePlayback();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          handlePreviousSentence();
          break;
        case 'ArrowRight':
          e.preventDefault();
          handleNextSentence();
          break;
        case 'r':
        case 'R':
          e.preventDefault();
          if (!isRecording) handleStartRecording();
          else handleStopRecording();
          break;
        case 'g':
        case 'G':
          e.preventDefault();
          dispatch(toggleGuide());
          break;
        case 't':
        case 'T':
          e.preventDefault();
          dispatch(toggleTranslation());
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [isRecording, dispatch]);

  // ÌòÑÏû¨ Î¨∏Ïû• Ï†ïÎ≥¥
  const sentences = currentContent?.content?.sentences || [];
  const totalSentences = sentences.length;

  // TTS ÏùåÏÑ± Ïû¨ÏÉù
  const handlePlayTTS = useCallback(async (text, speed = playback.speed) => {
    try {
      dispatch(setPlaybackState(true));
      
      const success = await playTTS(text, {
        speed,
        voiceGender: voiceSettings.ttsVoiceGender
      });

      if (success && config.autoAdvance && canGoNext) {
        setTimeout(() => {
          dispatch(goToNextSentence());
          dispatch(markSentenceCompleted(session.currentSentenceIndex));
        }, 1000);
      }
    } catch (err) {
      console.error('TTS error:', err);
      toast.error('ÏùåÏÑ± Ïû¨ÏÉùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
    } finally {
      dispatch(setPlaybackState(false));
    }
  }, [dispatch, playTTS, playback.speed, voiceSettings.ttsVoiceGender, config.autoAdvance, canGoNext, session.currentSentenceIndex]);

  // Ïû¨ÏÉù/ÏùºÏãúÏ†ïÏßÄ ÌÜ†Í∏Ä
  const togglePlayback = () => {
    if (!currentSentence) return;

    if (playback.isPlaying || isPlayingTTS) {
      dispatch(setPlaybackState(false));
    } else {
      handlePlayTTS(currentSentence.text);
    }
  };

  // Îã§Ïùå Î¨∏Ïû•
  const handleNextSentence = () => {
    if (canGoNext) {
      dispatch(goToNextSentence());
      dispatch(setPlaybackState(false));
      dispatch(markSentenceCompleted(session.currentSentenceIndex));
      
      // ÏßÑÌñâ ÏÉÅÌô© Î¶¨Ìè¨Ìä∏
      if (onProgress) {
        onProgress({
          currentIndex: session.currentSentenceIndex + 1,
          totalSentences,
          completedCount: session.completedSentences.size + 1,
          completionRate: ((session.completedSentences.size + 1) / totalSentences) * 100
        });
      }
      
      // ÏßÑÌñâ ÏÉÅÌô© ÌÜ†Ïä§Ìä∏
      const completionRate = Math.round(((session.completedSentences.size + 1) / totalSentences) * 100);
      if (completionRate === 25 || completionRate === 50 || completionRate === 75) {
        toast.success(`ÏßÑÌñâÎ•† ${completionRate}% Îã¨ÏÑ±! üéØ`);
      }
    }
  };

  // Ïù¥Ï†Ñ Î¨∏Ïû•
  const handlePreviousSentence = () => {
    if (canGoPrevious) {
      dispatch(goToPreviousSentence());
      dispatch(setPlaybackState(false));
    }
  };

  // Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú
  const resetReading = () => {
    dispatch(setCurrentSentence(0));
    dispatch(setPlaybackState(false));
    dispatch(setPronunciationScore({ score: null, analysis: null, feedback: null }));
    setStartTime(Date.now());
  };

  // ÏùåÏÑ± ÎÖπÏùå ÏãúÏûë
  const handleStartRecording = async () => {
    if (!currentSentence) return;
    
    try {
      dispatch(startRecording());
      const success = await startVoiceRecording();
      
      if (!success) {
        dispatch(stopRecording({ audioBlob: null, duration: 0 }));
        toast.error('ÎÖπÏùåÏùÑ ÏãúÏûëÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
      }
    } catch (error) {
      console.error('Recording start failed:', error);
      toast.error('ÎÖπÏùå ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      dispatch(stopRecording({ audioBlob: null, duration: 0 }));
    }
  };

  // ÏùåÏÑ± ÎÖπÏùå Ï§ëÏßÄ Î∞è Î∂ÑÏÑù
  const handleStopRecording = async () => {
    if (!isRecording || !currentSentence) return;

    try {
      const audioBlob = await stopVoiceRecording();
      dispatch(stopRecording({ audioBlob, duration: recordingDuration }));

      if (audioBlob) {
        // Î∞úÏùå Î∂ÑÏÑù ÏàòÌñâ
        const analysisResult = await analyzePronunciationAudio(
          audioBlob, 
          currentSentence.text, 
          level
        );

        if (analysisResult) {
          dispatch(setPronunciationScore({
            score: analysisResult.score,
            analysis: analysisResult.analysis,
            feedback: analysisResult.improvements
          }));
          
          // ÏÑ±Í≥µ ÌÜ†Ïä§Ìä∏
          if (analysisResult.score >= 80) {
            toast.success(`ÌõåÎ•≠Ìïú Î∞úÏùåÏûÖÎãàÎã§! ${analysisResult.score}Ï†ê`);
          } else if (analysisResult.score >= 60) {
            toast('Ï¢ãÏùÄ Î∞úÏùåÏù¥ÏóêÏöî! Ï°∞Í∏à Îçî Ïó∞ÏäµÌï¥Î≥¥ÏÑ∏Ïöî.', { icon: 'üëç' });
          } else {
            toast('Î∞úÏùåÏùÑ Îçî Ïó∞ÏäµÌï¥Î≥¥ÏÑ∏Ïöî.', { icon: 'üí™' });
          }
        }
      }
    } catch (error) {
      console.error('Recording analysis failed:', error);
      toast.error('Î∞úÏùå Î∂ÑÏÑùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
    }
  };

  // ÏÜçÎèÑ Î≥ÄÍ≤Ω Ï≤òÎ¶¨
  const handleSpeedChange = (newSpeed) => {
    dispatch(setPlaybackSpeed(newSpeed));
    updateVoiceSettings({ ttsSpeed: newSpeed });
  };

  // Î≥ºÎ•® Î≥ÄÍ≤Ω Ï≤òÎ¶¨
  const handleVolumeChange = (newVolume) => {
    dispatch(setVolume(newVolume));
  };

  // ÏùåÏÜåÍ±∞ ÌÜ†Í∏Ä
  const handleToggleMute = () => {
    dispatch(toggleMute());
  };

  // Ï†ÑÏ≤¥ ÏôÑÎ£å
  const completeReading = async () => {
    const finalData = {
      content_id: currentContent.content_id,
      completed_sentences: totalSentences,
      reading_speed: playback.speed,
      pronunciation_score: pronunciation.currentScore || 0,
      duration: startTime ? dateUtils.getTimeDifference(startTime) : 0
    };

    try {
      await dispatch(submitReading(finalData)).unwrap();
      dispatch(endSession());
      
      toast.success('ÏùΩÍ∏∞Î•º ÏôÑÎ£åÌñàÏäµÎãàÎã§! üéâ');
      
      if (onComplete) {
        onComplete(finalData);
      }
    } catch (error) {
      console.error('Reading completion failed:', error);
      toast.error('ÏôÑÎ£å Ï≤òÎ¶¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
    }
  };

  // Î¨∏Ïû•Î≥Ñ ÏßÑÌñâÎ•† Í≥ÑÏÇ∞
  const getProgress = () => {
    return (session.currentSentenceIndex / Math.max(1, totalSentences - 1)) * 100;
  };

  if (loading.content) {
    return (
      <div className={`bg-white rounded-xl shadow-lg p-8 text-center ${className}`}>
        <BookOpen className="w-12 h-12 text-gray-300 mx-auto mb-4" />
        <h3 className="text-lg font-medium text-gray-900 mb-2">
          ÏùΩÍ∏∞ ÏΩòÌÖêÏ∏†Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...
        </h3>
        <LoadingSpinner size="md" />
      </div>
    );
  }

  if (!currentContent) {
    return (
      <div className={`bg-white rounded-xl shadow-lg p-8 text-center ${className}`}>
        <BookOpen className="w-12 h-12 text-gray-300 mx-auto mb-4" />
        <h3 className="text-lg font-medium text-gray-900 mb-2">
          ÏΩòÌÖêÏ∏†Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§
        </h3>
        <Button 
          onClick={() => {
            dispatch(fetchJourneyContent({ level, type: 'reading' }));
            toast.loading('ÏΩòÌÖêÏ∏†Î•º Îã§Ïãú Î∂àÎü¨Ïò§Îäî Ï§ë...');
          }}
          className="mt-4"
        >
          Îã§Ïãú ÏãúÎèÑ
        </Button>
      </div>
    );
  }

  return (
    <div className={`bg-white rounded-xl shadow-lg ${className}`}>
      
      {/* Ìó§Îçî */}
      <div className="border-b border-gray-200 p-6">
        <div className="flex items-center justify-between mb-4">
          <div>
            <h2 className="text-xl font-semibold text-gray-900">{currentContent.title}</h2>
            <p className="text-gray-600">{currentContent.description}</p>
          </div>
          <div className="flex items-center space-x-2">
            <span className="px-3 py-1 bg-blue-100 text-blue-800 text-sm rounded-full">
              {config.name}
            </span>
            <span className="text-sm text-gray-500">
              {session.currentSentenceIndex + 1} / {totalSentences}
            </span>
          </div>
        </div>

        {/* ÏßÑÌñâÎ•† Î∞î */}
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div 
            className="bg-blue-600 h-2 rounded-full transition-all duration-300"
            style={{ width: `${getProgress()}%` }}
          />
        </div>
      </div>

      {/* Î©îÏù∏ ÏùΩÍ∏∞ ÏòÅÏó≠ */}
      <div className="p-6">
        
        {/* ÌòÑÏû¨ Î¨∏Ïû• ÌëúÏãú */}
        <div className="text-center mb-8">
          <div 
            ref={textRef}
            className="text-2xl md:text-3xl leading-relaxed text-gray-900 mb-4 min-h-[100px] flex items-center justify-center"
          >
            {currentSentence ? (
              config.showHangulBreakdown ? (
                <HangulDisplay 
                  text={currentSentence.text}
                  level={level}
                  showBreakdown={true}
                />
              ) : (
                <span className="tracking-wide">{currentSentence.text}</span>
              )
            ) : (
              <span className="text-gray-400">Î¨∏Ïû•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</span>
            )}
          </div>

          {/* Î≤àÏó≠ ÌëúÏãú */}
          {ui.showTranslation && currentSentence?.translation && (
            <div className="text-lg text-gray-600 italic mb-4">
              "{currentSentence.translation}"
            </div>
          )}

          {/* Î∞úÏùå ÌîºÎìúÎ∞± */}
          {pronunciation.currentScore !== null && (
            <PronunciationFeedback 
              score={pronunciation.currentScore}
              analysis={pronunciation.analysis}
              suggestions={pronunciation.feedback || []}
              originalText={currentSentence?.text || ''}
              onRetry={handleStartRecording}
              onPlayReference={() => handlePlayTTS(currentSentence?.text)}
              className="mb-4"
            />
          )}
        </div>

        {/* Ïª®Ìä∏Î°§ Ìå®ÎÑê */}
        <div className="space-y-6">
          
          {/* Î©îÏù∏ Ïû¨ÏÉù Ïª®Ìä∏Î°§ */}
          <div className="flex items-center justify-center space-x-4">
            <Button
              variant="outline"
              size="sm"
              onClick={handlePreviousSentence}
              disabled={!canGoPrevious}
              className="p-3"
            >
              <SkipBack className="w-5 h-5" />
            </Button>

            <Button
              onClick={togglePlayback}
              disabled={!currentSentence}
              className={`p-4 ${
                playback.isPlaying || isPlayingTTS 
                  ? 'bg-red-500 hover:bg-red-600' 
                  : 'bg-blue-500 hover:bg-blue-600'
              } text-white rounded-full`}
            >
              {playback.isPlaying || isPlayingTTS ? (
                <Pause className="w-6 h-6" />
              ) : (
                <Play className="w-6 h-6" />
              )}
            </Button>

            <Button
              variant="outline"
              size="sm"
              onClick={handleNextSentence}
              disabled={!canGoNext}
              className="p-3"
            >
              <SkipForward className="w-5 h-5" />
            </Button>
          </div>

          {/* ÏÜçÎèÑ Î∞è Î≥ºÎ•® Ïª®Ìä∏Î°§ */}
          <div className="flex items-center justify-center space-x-6">
            <SpeedControl
              speed={playback.speed}
              onSpeedChange={handleSpeedChange}
              level={level}
            />

            <div className="flex items-center space-x-2">
              <Button
                variant="ghost"
                size="sm"
                onClick={handleToggleMute}
                className="p-2"
              >
                {playback.isMuted ? <VolumeX className="w-4 h-4" /> : <Volume2 className="w-4 h-4" />}
              </Button>
              
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={playback.isMuted ? 0 : playback.volume}
                onChange={(e) => handleVolumeChange(parseFloat(e.target.value))}
                className="w-20 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                disabled={playback.isMuted}
              />
            </div>
          </div>

          {/* Ï∂îÍ∞Ä Ïª®Ìä∏Î°§ */}
          <div className="flex items-center justify-center space-x-3">
            <Button
              variant="outline"
              size="sm"
              onClick={() => dispatch(toggleGuide())}
              className={`flex items-center space-x-2 ${ui.showGuide ? 'bg-yellow-50 border-yellow-200' : ''}`}
            >
              <Lightbulb className="w-4 h-4" />
              <span>{ui.showGuide ? 'Í∞ÄÏù¥Îìú Ïà®Í∏∞Í∏∞' : 'ÌïôÏäµ Í∞ÄÏù¥Îìú'}</span>
            </Button>

            <Button
              variant="outline"
              size="sm"
              onClick={() => dispatch(toggleTranslation())}
              className={`flex items-center space-x-2 ${ui.showTranslation ? 'bg-blue-50 border-blue-200' : ''}`}
            >
              {ui.showTranslation ? <EyeOff className="w-4 h-4" /> : <Eye className="w-4 h-4" />}
              <span>Î≤àÏó≠</span>
            </Button>

            <Button
              variant="outline"
              size="sm"
              onClick={resetReading}
              className="flex items-center space-x-2"
            >
              <RotateCcw className="w-4 h-4" />
              <span>Ï≤òÏùåÎ∂ÄÌÑ∞</span>
            </Button>
          </div>

          {/* ÏùåÏÑ± ÎÖπÏùå Î≤ÑÌäº (Î†àÎ≤® 2 Ïù¥ÏÉÅ) */}
          {level !== 'level1' && (
            <div className="text-center">
              <Button
                variant={isRecording ? "solid" : "outline"}
                onClick={isRecording ? handleStopRecording : handleStartRecording}
                disabled={isProcessing}
                className={`flex items-center space-x-2 ${
                  isRecording 
                    ? 'bg-red-500 hover:bg-red-600 text-white animate-pulse' 
                    : ''
                }`}
              >
                <div className={`w-3 h-3 rounded-full ${
                  isRecording ? 'bg-white' : 'bg-red-500'
                }`} />
                <span>
                  {isProcessing 
                    ? 'Î∂ÑÏÑù Ï§ë...' 
                    : isRecording 
                    ? 'ÎÖπÏùå Ï§ëÏßÄ' 
                    : 'Î∞úÏùå Ïó∞Ïäµ'
                  }
                </span>
              </Button>
              
              {/* ÎÖπÏùå Î†àÎ≤® ÌëúÏãú */}
              {isRecording && (
                <div className="mt-2 flex items-center justify-center space-x-2">
                  <div className="w-20 h-1 bg-gray-200 rounded-full overflow-hidden">
                    <div 
                      className="h-full bg-red-500 transition-all duration-100"
                      style={{ width: `${audioLevel * 100}%` }}
                    />
                  </div>
                  <span className="text-xs text-gray-500">
                    {Math.round(recordingDuration / 1000)}s
                  </span>
                </div>
              )}
            </div>
          )}
        </div>

        {/* ÌïôÏäµ Í∞ÄÏù¥Îìú */}
        {ui.showGuide && currentContent.guide && (
          <div className="mt-8 bg-blue-50 border border-blue-200 rounded-lg p-6">
            <h3 className="font-semibold text-blue-900 mb-4 flex items-center">
              <Lightbulb className="w-5 h-5 mr-2" />
              ÌïôÏäµ Í∞ÄÏù¥Îìú
            </h3>
            
            <div className="grid md:grid-cols-2 gap-6">
              {/* Ïñ¥Ìúò */}
              {currentContent.guide.vocabulary?.length > 0 && (
                <div>
                  <h4 className="font-medium text-blue-800 mb-2">Ï£ºÏöî Ïñ¥Ìúò</h4>
                  <ul className="space-y-1 text-sm text-blue-700">
                    {currentContent.guide.vocabulary.map((item, index) => (
                      <li key={index}>‚Ä¢ {item}</li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Î∞úÏùå ÌåÅ */}
              {currentContent.guide.pronunciation?.length > 0 && (
                <div>
                  <h4 className="font-medium text-blue-800 mb-2">Î∞úÏùå ÌåÅ</h4>
                  <ul className="space-y-1 text-sm text-blue-700">
                    {currentContent.guide.pronunciation.map((tip, index) => (
                      <li key={index}>‚Ä¢ {tip}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Î¨∏Ïû• ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò */}
        <div className="mt-8 border-t border-gray-200 pt-6">
          <h3 className="font-medium text-gray-900 mb-4">Î¨∏Ïû• Î™©Î°ù</h3>
          <div className="grid gap-2 max-h-40 overflow-y-auto">
            {sentences.map((sentence, index) => (
              <button
                key={index}
                onClick={() => {
                  dispatch(setCurrentSentence(index));
                  dispatch(setPlaybackState(false));
                }}
                className={`text-left p-3 rounded-lg transition-colors ${
                  index === session.currentSentenceIndex
                    ? 'bg-blue-100 border-blue-200 text-blue-900'
                    : session.completedSentences.has(index)
                    ? 'bg-green-50 border-green-200 text-green-900'
                    : 'bg-gray-50 border-gray-200 text-gray-700 hover:bg-gray-100'
                } border`}
              >
                <div className="flex items-center justify-between">
                  <span className="text-sm truncate">{sentence.text}</span>
                  <div className="flex items-center space-x-1 ml-2">
                    {session.completedSentences.has(index) && (
                      <div className="w-2 h-2 bg-green-500 rounded-full" />
                    )}
                    <span className="text-xs text-gray-500">{index + 1}</span>
                  </div>
                </div>
              </button>
            ))}
          </div>
        </div>

        {/* ÏôÑÎ£å Î≤ÑÌäº */}
        {session.currentSentenceIndex === totalSentences - 1 && (
          <div className="mt-6 text-center">
            <Button
              onClick={completeReading}
              disabled={loading.submit}
              className="bg-green-600 hover:bg-green-700 text-white px-8 py-3"
            >
              {loading.submit ? 'Ï†úÏ∂ú Ï§ë...' : 'ÏùΩÍ∏∞ ÏôÑÎ£åÌïòÍ∏∞'}
            </Button>
          </div>
        )}
      </div>

      {/* ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§ ÏïàÎÇ¥ */}
      <div className="border-t border-gray-200 px-6 py-4 bg-gray-50 rounded-b-xl">
        <div className="text-xs text-gray-500 text-center space-x-4">
          <span>Ïä§ÌéòÏù¥Ïä§: Ïû¨ÏÉù/ÏùºÏãúÏ†ïÏßÄ</span>
          <span>‚Üê/‚Üí: Ïù¥Ï†Ñ/Îã§Ïùå Î¨∏Ïû•</span>
          <span>R: ÎÖπÏùå</span>
          <span>G: Í∞ÄÏù¥Îìú</span>
          <span>T: Î≤àÏó≠</span>
        </div>
      </div>
    </div>
  );
};

export default ReadingPanel;